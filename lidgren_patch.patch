Index: Lidgren.Network.csproj
===================================================================
--- Lidgren.Network.csproj	(revision 352)
+++ Lidgren.Network.csproj	(working copy)
@@ -10,7 +10,7 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>Lidgren.Network</RootNamespace>
     <AssemblyName>Lidgren.Network</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <PublishUrl>publish\</PublishUrl>
     <Install>true</Install>
@@ -27,6 +27,7 @@
     <IsWebBootstrapper>false</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -38,6 +39,7 @@
     <WarningLevel>4</WarningLevel>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <DocumentationFile>bin\Debug\Lidgren.Network.XML</DocumentationFile>
+    <PlatformTarget>x86</PlatformTarget>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -47,11 +49,12 @@
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <DocumentationFile>bin\Release\Lidgren.Network.XML</DocumentationFile>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core" />
-    <Reference Include="Microsoft.CSharp" />
     <Reference Include="System.Data" />
     <Reference Include="System.Xml" />
   </ItemGroup>
Index: NetBuffer.cs
===================================================================
--- NetBuffer.cs	(revision 352)
+++ NetBuffer.cs	(working copy)
@@ -69,8 +69,39 @@
 		{
 			get { return (int)(m_readPosition / 8); }
 		}
-		
-		static NetBuffer()
+
+        /// <summary>
+        /// Gets the remaining number of bits in the buffer to be read
+        /// </summary>
+	    public long RemainingBits
+	    {
+            get { return (long)(m_bitLength - m_readPosition); }
+	    }
+        
+        /// <summary>
+        /// Clones this buffer into dest
+        /// </summary>
+        /// <param name="dest"></param>
+        public void Clone(NetBuffer dest)
+        {
+            dest.m_data = new byte[m_data.Length];
+
+            Buffer.BlockCopy(m_data, 0, dest.m_data, 0, m_data.Length);
+            //foreach loops are faster in release builds until about 32k of bytes. supposedly. probably has something to do with the method call taking time.
+            //dest.m_data = new byte[m_data.Length];
+            //var i = 0;
+            //foreach (var by in m_data)
+            //{
+            //    dest.m_data[i] = by;
+            //    ++i;
+            //}
+
+            //set other values...
+            dest.m_bitLength = m_bitLength;
+            dest.m_readPosition = 0;
+        }
+
+        static NetBuffer()
 		{
 			s_readMethods = new Dictionary<Type, MethodInfo>();
 			MethodInfo[] methods = typeof(NetIncomingMessage).GetMethods(BindingFlags.Instance | BindingFlags.Public);
Index: NetConnectionStatistics.cs
===================================================================
--- NetConnectionStatistics.cs	(revision 352)
+++ NetConnectionStatistics.cs	(working copy)
@@ -177,7 +177,7 @@
 				if (relSendChan != null)
 				{
 					for (int i = 0; i < relSendChan.m_storedMessages.Length; i++)
-						if (relSendChan.m_storedMessages[i].Message != null)
+                        if ((relSendChan.m_usedStoredMessages & ((ulong)1 << i)) != 0)
 							numStored++;
 				}
 			}
Index: NetConstants.cs
===================================================================
--- NetConstants.cs	(revision 352)
+++ NetConstants.cs	(working copy)
@@ -33,9 +33,9 @@
 
 		internal const int HeaderByteSize = 5;
 
-		internal const int UnreliableWindowSize = 128;
-		internal const int ReliableOrderedWindowSize = 64;
-		internal const int ReliableSequencedWindowSize = 64;
+		internal const int UnreliableWindowSize = 1024;
+		internal const int ReliableOrderedWindowSize = 64; // MAX: 64
+        internal const int ReliableSequencedWindowSize = 64; // MAX: 64
 		internal const int DefaultWindowSize = 64;
 
 		internal const int MaxFragmentationGroups = ushort.MaxValue - 1;
Index: NetPeer.Internal.cs
===================================================================
--- NetPeer.Internal.cs	(revision 352)
+++ NetPeer.Internal.cs	(working copy)
@@ -1,5 +1,5 @@
 ï»¿#if !__ANDROID__ && !IOS
-#define IS_MAC_AVAILABLE
+//#define IS_MAC_AVAILABLE
 #endif
 
 using System;
Index: NetReliableSenderChannel.cs
===================================================================
--- NetReliableSenderChannel.cs	(revision 352)
+++ NetReliableSenderChannel.cs	(working copy)
@@ -14,6 +14,7 @@
 		private int m_sendStart;
 
 		private NetBitVector m_receivedAcks;
+        internal ulong m_usedStoredMessages; // "used" bits for storedMessages
 		internal NetStoredReliableMessage[] m_storedMessages;
 
 		internal float m_resendDelay;
@@ -27,6 +28,8 @@
 			m_windowStart = 0;
 			m_sendStart = 0;
 			m_receivedAcks = new NetBitVector(NetConstants.NumSequenceNumbers);
+            NetException.Assert(m_windowSize <= 64); // we do only have sizeof(ulong)*8 "used" bits in m_usedStoredMessages
+            m_usedStoredMessages = 0;
 			m_storedMessages = new NetStoredReliableMessage[m_windowSize];
 			m_queuedSends = new NetQueue<NetOutgoingMessage>(8);
 			m_resendDelay = m_connection.GetResendDelay();
@@ -66,37 +69,39 @@
 			//
 			// resends
 			//
-			for (int i = 0; i < m_storedMessages.Length; i++)
-			{
-				NetOutgoingMessage om = m_storedMessages[i].Message;
-				if (om == null)
-					continue;
+            if (m_usedStoredMessages != 0)
+            {
+                for (int i = 0; i < m_storedMessages.Length; i++)
+                {
+                    if ((m_usedStoredMessages & ((ulong)1 << i)) == 0)
+                        continue;
 
-				float t = m_storedMessages[i].LastSent;
-				if (t > 0 && (now - t) > m_resendDelay)
-				{
-					// deduce sequence number
-					/*
-					int startSlot = m_windowStart % m_windowSize;
-					int seqNr = m_windowStart;
-					while (startSlot != i)
-					{
-						startSlot--;
-						if (startSlot < 0)
-							startSlot = m_windowSize - 1;
-						seqNr--;
-					}
-					*/
+                    float t = m_storedMessages[i].LastSent;
+                    if (t > 0 && (now - t) > m_resendDelay)
+                    {
+                        // deduce sequence number
+                        /*
+                        int startSlot = m_windowStart % m_windowSize;
+                        int seqNr = m_windowStart;
+                        while (startSlot != i)
+                        {
+                            startSlot--;
+                            if (startSlot < 0)
+                                startSlot = m_windowSize - 1;
+                            seqNr--;
+                        }
+                        */
 
-					//m_connection.m_peer.LogVerbose("Resending due to delay #" + m_storedMessages[i].SequenceNumber + " " + om.ToString());
-					m_connection.m_statistics.MessageResent(MessageResendReason.Delay);
+                        //m_connection.m_peer.LogVerbose("Resending due to delay #" + m_storedMessages[i].SequenceNumber + " " + om.ToString());
+                        m_connection.m_statistics.MessageResent(MessageResendReason.Delay);
 
-					m_connection.QueueSendMessage(om, m_storedMessages[i].SequenceNumber);
+                        m_connection.QueueSendMessage(m_storedMessages[i].Message, m_storedMessages[i].SequenceNumber);
 
-					m_storedMessages[i].LastSent = now;
-					m_storedMessages[i].NumSent++;
-				}
-			}
+                        m_storedMessages[i].LastSent = now;
+                        m_storedMessages[i].NumSent++;
+                    }
+                }
+            }
 
 			int num = GetAllowedSends();
 			if (num < 1)
@@ -121,8 +126,9 @@
 			m_connection.QueueSendMessage(message, seqNr);
 
 			int storeIndex = seqNr % m_windowSize;
-			NetException.Assert(m_storedMessages[storeIndex].Message == null);
+			NetException.Assert((m_usedStoredMessages & ((ulong)1 << storeIndex)) == 0);
 
+            m_usedStoredMessages |= (ulong)1 << storeIndex; // set used bit
 			m_storedMessages[storeIndex].NumSent++;
 			m_storedMessages[storeIndex].Message = message;
 			m_storedMessages[storeIndex].LastSent = now;
@@ -148,6 +154,7 @@
 #if !DEBUG
 			}
 #endif
+            m_usedStoredMessages &= ~((ulong)1 << storeIndex); // clear used bit
 			m_storedMessages[storeIndex] = new NetStoredReliableMessage();
 		}
 
@@ -182,7 +189,7 @@
 					m_receivedAcks[m_windowStart] = false;
 					DestoreMessage(m_windowStart % m_windowSize);
 
-					NetException.Assert(m_storedMessages[m_windowStart % m_windowSize].Message == null); // should already be destored
+                    NetException.Assert((m_usedStoredMessages & ((ulong)1 << (m_windowStart % m_windowSize))) == 0); // should already be destored
 					m_windowStart = (m_windowStart + 1) % NetConstants.NumSequenceNumbers;
 					//m_connection.m_peer.LogDebug("Advancing window to #" + m_windowStart);
 				}
Index: NetUtility.cs
===================================================================
--- NetUtility.cs	(revision 352)
+++ NetUtility.cs	(working copy)
@@ -17,7 +17,7 @@
 USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 #if !__ANDROID__ && !IOS
-#define IS_FULL_NET_AVAILABLE
+//#define IS_FULL_NET_AVAILABLE
 #endif
 
 using System;
